import torch
import torch.nn as nn  
import torch.optim as optim  
import os
import custom_dataset as cd
from custom_models import LeNet5

def model_accuracy(model, loader):
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for data, labels in loader:
            data = data.to(device=cd.device)
            labels = labels.view(-1, 1).to(device=cd.device)  # Reshape the labels tensor
            outputs = model(data)
            predicted = torch.round(outputs)  # Round the output probabilities to get the predicted classes
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    return correct / total

# Model
model = LeNet5()
model.to(cd.device)  # Move model to GPU if available

# Define the loss function and optimizer
criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=cd.learning_rate, weight_decay=cd.weight_decay)

patience = 1  # Number of epochs to wait for improvement before stopping
best_loss = float('inf')  # Best loss value so far
epochs_without_improvement = 0  # Number of epochs without improvement

# Train the model
for epoch in range(cd.num_epochs):
    model.train()
    for data, targets in cd.train_loader:
        # Move data to device
        data = data.to(device=cd.device)
        targets = targets.to(device=cd.device)

        # Forward pass
        scores = model(data)
        targets = targets.view(-1, 1)
        loss = criterion(scores, targets.float())

        # Backward pass and optimize
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    model.eval()
    with torch.no_grad():
        validation_loss = sum(criterion(model(data.to(device=cd.device)), targets.view(-1, 1).float().to(device=cd.device)) for data, targets in cd.validation_loader) / len(cd.validation_loader)
    
    print(f'Epoch [{epoch+1}/{cd.num_epochs}], Training Loss: {loss.item()}, Validation Loss: {validation_loss}')

    validation_accuracy = model_accuracy(model, cd.validation_loader)
    print(f'Validation Accuracy after epoch {epoch+1}: {validation_accuracy*100:.2f}%')

    # Check for improvement
    if validation_loss < best_loss:
        best_loss = validation_loss
        epochs_without_improvement = 0
    else:
        epochs_without_improvement += 1
        if epochs_without_improvement == patience:
            print('Early stopping')
            break


test_accuracy = model_accuracy(model, cd.test_loader)
print(f'Test Accuracy: {test_accuracy*100:.2f}%')

model_directory = os.path.join(cd.directory, "model.pth")

torch.save(model.state_dict(), model_directory)
