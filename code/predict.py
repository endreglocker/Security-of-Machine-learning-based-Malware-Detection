import os
import torch
from model.custom_models import Net
import matplotlib.pyplot as plt
import load_data as ld

def performance(malwares, benigns, model):
    errors = 0
    for malware in malwares:
        data, _, original_length = ld.file_to_array(malware) # contains a tensor and the ground truth label
        data = data.unsqueeze(0)
        data = data.to(next(model.parameters()).device)
        output = model(data)
        prediction = torch.sigmoid(output).round().int().item()
        if(prediction == 0):
            errors += 1
        
        ld.revert_tensor_to_bytes(data, malware, original_length)

    total = len(malwares)

    print(f"Malware Accuracy: {1 - errors/total}")
    print(f"Malware Errors: {errors}/{total}")

    errors = 0
    for benign in benigns:
        data = ld.file_to_array(benign) # contains a tensor and the ground truth label
        data = data.unsqueeze(0)
        data = data.to(next(model.parameters()).device)
        output = model(data)
        prediction = torch.sigmoid(output).round().int().item()
        if(prediction == 1):
            errors += 1
        
        ld.revert_tensor_to_bytes(data, benign, original_length)

    total = len(malwares)

    print(f"Benign Accuracy: {1 - errors/total}")
    print(f"Benign Errors: {errors}/{total}")


dict = {0: 'Benign', 1: 'Malware'}


directory = os.path.join(os.getcwd(), "code", "model",'model256_v2.pth')

loading = torch.load(directory, map_location=torch.device('cpu'))

model = Net()

model.load_state_dict(loading)
model.eval()

malwares, benigns = ld.load_file_names()

#performance(malwares, benigns, model)

data, ground_truth, original_length = ld.file_to_array(malwares[0]) # contains a tensor and the ground truth label

data = data.unsqueeze(0)

# Make sure the data tensor is on the same device as the model
data = data.to(next(model.parameters()).device)
data.requires_grad = True

# Make a prediction
output = model(data)
output.backward()

prediction = torch.sigmoid(output).round().int().item()
print(f"Prob: {output}")
print(prediction)
print(dict[prediction])

# Make a prediction
output = model(data)

saliency, _ = torch.max(data.grad.data.abs(),dim=1)

saliency = saliency.view(256, 256)
plt.imshow(saliency, cmap=plt.cm.hot)
plt.title(dict[prediction])
#plt.show()

file_name = os.path.basename(malwares[0][0])
ld.revert_tensor_to_bytes(data, file_name, original_length)