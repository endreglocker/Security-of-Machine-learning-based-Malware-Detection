import os
from PIL import Image
import torch
import torchvision.transforms as transforms  
from model.custom_models import Net
import matplotlib.pyplot as plt
import load_images as li

def performance(malwares, benigns, model):
    errors = 0
    for m in malwares:
        data = li.file_to_array(m) # contains a tensor and the ground truth label
        data = data.unsqueeze(0)
        data = data.to(next(model.parameters()).device)
        output = model(data)
        prediction = torch.sigmoid(output).round().int().item()
        if(prediction == 0):
            errors += 1

    total = len(malwares)

    print(f"Malware Accuracy: {1 - errors/total}")
    print(f"Malware Errors: {errors}/{total}")

    errors = 0
    for m in benigns:
        data = li.file_to_array(m) # contains a tensor and the ground truth label
        data = data.unsqueeze(0)
        data = data.to(next(model.parameters()).device)
        output = model(data)
        prediction = torch.sigmoid(output).round().int().item()
        if(prediction == 1):
            errors += 1

    total = len(malwares)

    print(f"Benign Accuracy: {1 - errors/total}")
    print(f"Benign Errors: {errors}/{total}")


dict = {0: 'Benign', 1: 'Malware'}


directory = os.path.join(os.getcwd(), "code", "model",'model256_v2.pth')

loading = torch.load(directory, map_location=torch.device('cpu'))

model = Net()

model.load_state_dict(loading)
model.eval()

malwares, benigns = li.load_data()

#performance(malwares, benigns, model)

data = li.file_to_array(malwares[0]) # contains a tensor and the ground truth label

data = data.unsqueeze(0)

# Make sure the data tensor is on the same device as the model
data = data.to(next(model.parameters()).device)
data.requires_grad = True

# Make a prediction
output = model(data)
output.backward()

prediction = torch.sigmoid(output).round().int().item()
print(f"Prob: {output}")
#print(f"Probability: {torch.sigmoid(output).item() if prediction == 1 else 1 - torch.sigmoid(output).item()}")
print(prediction)
print(dict[prediction])

# Make a prediction
output = model(data)

saliency, _ = torch.max(data.grad.data.abs(),dim=1)

saliency = saliency.view(256, 256)
plt.imshow(saliency, cmap=plt.cm.hot)
plt.title(dict[prediction])
plt.show()

