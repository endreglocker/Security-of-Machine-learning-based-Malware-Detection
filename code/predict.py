import os
import torch
from model.custom_models import Net
import matplotlib.pyplot as plt
import load_data as ld

def performance(malwares, benigns, model):
    errors = 0
    for malware in malwares:
        data, _, _, _ = ld.file_to_array(malware) # contains a tensor and the ground truth label
        data = data.unsqueeze(0)
        data = data.to(next(model.parameters()).device)
        output = model(data)
        prediction = torch.sigmoid(output).round().int().item()
        if(prediction == 0):
            errors += 1        
    total = len(malwares)
    print(f"Malware Accuracy: {1 - errors/total}")
    print(f"Malware Errors: {errors}/{total}")

    errors = 0
    for benign in benigns:
        data, _, _, _ = ld.file_to_array(benign) # contains a tensor and the ground truth label
        data = data.unsqueeze(0)
        data = data.to(next(model.parameters()).device)
        output = model(data)
        prediction = torch.sigmoid(output).round().int().item()
        if(prediction == 1):
            errors += 1
    total = len(malwares)
    print(f"Benign Accuracy: {1 - errors/total}")
    print(f"Benign Errors: {errors}/{total}")

dict = {0: 'Benign', 1: 'Malware'}

directory = os.path.join(os.getcwd(), "code", "model",'model256_v2.pth')
loading = torch.load(directory, map_location=torch.device('cpu'))

model = Net()
model.load_state_dict(loading)
model.eval()

malwares, benigns = ld.load_file_names()

performance(malwares, benigns, model)

data, ground_truth, original_length, _ = ld.file_to_array(malwares[0]) # contains a tensor and the ground truth label
data = data.unsqueeze(0)

# Make sure the data tensor is on the same device as the model
data = data.to(next(model.parameters()).device)
data.requires_grad = True

# Predict whether the data is malware or benign and print the
output = model(data)
output.backward()
prediction = torch.sigmoid(output).round().int().item()
print(f"Prob: {output}")
print(prediction)
print(dict[prediction])

# optional visualization of the saliency map
"""
saliency, _ = torch.max(data.grad.data.abs(),dim=1)

saliency = saliency.view(256, 256)
plt.imshow(saliency, cmap=plt.cm.hot)
plt.title(dict[prediction])
plt.show()
"""