import os
import torch
import attack_implementations as aim
import torch.nn as nn
import sys
sys.path.append(os.path.join(os.getcwd(), "code", "model"))
from custom_models import Net

sys.path.append(os.path.join(os.getcwd(), "code"))
import load_data as ld

# Load the model & set it to evaluation mode
directory = os.path.join(os.getcwd(), "code", "model",'model256_v2.pth')

loading = torch.load(directory, map_location=torch.device('cpu'))

model = Net()

model.load_state_dict(loading)
model.eval()

# Load the datasets
file_percentage = 0.07
malwares, benigns = ld.load_file_names()
data_array, ground_truth, original_size_of_file, isBiggerorEqual = ld.file_to_array(malwares[0], percentage=file_percentage)
data_array = data_array.unsqueeze(0)

data_array = data_array.to(next(model.parameters()).device)
data_array.requires_grad = True

# Set the hyperparameters for the attack
epsilon = 1
alpha = 1e-2
num_iter = 40
restarts = 20
loss_fn = nn.BCEWithLogitsLoss()
model_input_data_length = 256*256

# Calculate the percentage scaling factor if the file is compressed

rate_of_compression = original_size_of_file / model_input_data_length

# AKKOR KÉNE MODIFIED PERCENTAGE-T HASZNÁLNI, HA A MODEL INPUT MÉRET NAGYOBB, MINT A FILE MÉRET, TEHÁT HA SZÉT PUFFERELJÜK A FILE-T
# percentage of the new length: percentage_of_new = x * percentage / (x * (1 + percentage)) = percentage / (1 + percentage)
percentage_length_of_concatenated_file = file_percentage / (1 + file_percentage) # calculating the percetage of the suffix compared to the file, after adding suffinx to it
modified_percentage = percentage_length_of_concatenated_file *  rate_of_compression # calculating the percentage of the suffix compared to the file, after adding suffinx to it
targeted_percentage = percentage_length_of_concatenated_file if isBiggerorEqual else modified_percentage
#print(f"Percentage of concatenated file: {percentage_length_of_concatenated_file}")

# Attack the model
delta = aim.pgd_linf_rand(model, data_array, ground_truth, epsilon, alpha, num_iter, restarts, loss_fn, percentage_length_of_concatenated_file)
# copy of delta without a reference to it
delta_copy = delta.detach().clone()
delta_copy.clamp_(0,1)

# get suffix to add to the original file
size_with_suffix = int(original_size_of_file * (1 + file_percentage))
suffix = ld.suffix_to_bytes(delta_copy, size_with_suffix, isBiggerorEqual, targeted_percentage, percentage_length_of_concatenated_file)
# read file
read_original_file = ld.read_file(malwares[0])
# add perturbated suffix to file
read_original_file.extend(suffix)
# resize it to the model's input size
resized_orginal_file, _ = ld.resize_array(read_original_file)
# transform it to tensor
original_file_concatenated_with_suffix_as_tensor = ld.transform_to_tensor(resized_orginal_file) 
original_file_concatenated_with_suffix_as_tensor.unsqueeze_(0)
original_file_concatenated_with_suffix_as_tensor = original_file_concatenated_with_suffix_as_tensor.to(next(model.parameters()).device)
original_file_concatenated_with_suffix_as_tensor.requires_grad = True
# evaluate the file with the added suffix
added_suffix_eval = model(original_file_concatenated_with_suffix_as_tensor)
added_suffix_eval.backward()

# Evaluate the original data
data_prediction = model(data_array)
data_prediction.backward()

# Create the perturbated data
perturbated_image = data_array + delta
perturbated_image.clamp_(0, 1)

perturbated_image_leaf = perturbated_image.detach().clone()
perturbated_image_leaf.requires_grad = True

perturbated_pred = model(perturbated_image_leaf)
perturbated_pred.backward()

dict = {0: "benign", 1: "malware"}
sol_o = torch.sigmoid(data_prediction).round().int().item()
sol_p = torch.sigmoid(perturbated_pred).round().int().item()
sol_with_added_suffix = torch.sigmoid(added_suffix_eval).round().int().item()

print(f"Original:\t\t\t\t{dict[sol_o]}")
print(f"Perturbated via algorithm:\t\t{dict[sol_p]}")
print(f"Perturbated via adding suffix:\t\t{dict[sol_with_added_suffix]}")

print(f"Original prediction: {torch.sigmoid(data_prediction).item()}")
print(f"Perturbated prediction: {torch.sigmoid(perturbated_pred).item()}")
print(f"Perturbated prediction with added suffix: {torch.sigmoid(added_suffix_eval).item()}")

aim.plot_images(original_file_concatenated_with_suffix_as_tensor, perturbated_image_leaf, delta, dict[sol_o], dict[sol_p])


